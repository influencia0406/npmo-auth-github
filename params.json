{"name":"Npmo-auth-GitHub","tagline":"GitHub powered authentication/authorization strategy for npm On-Site.","body":"# npme-auth-github\r\nGitHub authentication and authorization strategy for npm Enterprise.\r\n\r\n## Implementing your own authentication strategy\r\n\r\n### npm Enterprise authentication flow\r\n\r\n1. npm CLI calls the frontdoor host with a request to authenticate when `npm login`\r\nis invoked.\r\n2. Frontdoor host calls the authentication webservice with a payload including\r\nthe credentials user input.\r\n3. Authentication webservice calls its configured authentication strategy, passing\r\nthe payload received to it.\r\n4. Authentication strategy either returns an object with a token and an user\r\nobject to persist into the session store if authentication succeeded or no\r\ntoken and an optional message if authentication failed (see below for the\r\nexact API).\r\n5. If authentication succeeded, frontdoor passes the token back to npm CLI.\r\nnpm CLI will further use the token to authorize its request.\r\n\r\n### Authentication strategy API\r\n\r\nYour module needs to export an `Authenticator` property.  `Authenticator` is\r\ncalled with an object containing options for the running npm Enterprise instance\r\nand needs to return an object with an `authenticate` function, for example:\r\n\r\n```js\r\nvar Authenticator = exports.Authenticator = function(opts) {\r\n};\r\n\r\nAuthenticator.prototype.authenticate = function(credentials, cb) {\r\n};\r\n```\r\n\r\nor\r\n\r\n```js\r\nexports.Authenticator = function (opts) {\r\n  function authenticate(credentials, cb) {\r\n  }\r\n\r\n  return {\r\n    authenticate: authenticate\r\n  };\r\n};\r\n```\r\n\r\nThe `authenticate` function is called with an object containing a `body` property,\r\nwhich is what the npm CLI called the frontdoor host with:\r\n\r\n```js\r\n{\r\n  body: {\r\n    name: 'foobar',\r\n    email: 'foobar@mycorp.com',\r\n    password: 'iloveicecream'\r\n  }\r\n}\r\n```\r\n\r\nBasing on this, you should authenticate the user.\r\n\r\nIf authentication succeeds, you should call the callback with no error and an\r\nobject with `token` and `user` properties. `token` will be passed back to npm\r\nCLI in order to authorize further requests, and `user` will be persisted into\r\nthe session store.\r\n\r\n```js\r\ncb(null, {\r\n  token: \"username-authtoken\",\r\n  user: {\r\n    name: 'foobar',\r\n    email: 'foobar@mycorp.com'\r\n  }\r\n});\r\n```\r\n\r\nIf authentication isn't correct, you should call the callback with no error\r\nand an object with optional `message` property which will be displayed to the\r\nuser:\r\n\r\n```js\r\ncb(null, {\r\n  message: \"You don't work here anymore\"\r\n});\r\n```\r\n\r\nIf authentication errors out (for example, your internal authentication server\r\nis down, you should call the callback with an error object:\r\n\r\n```js\r\ncb(new Error('Internal authentication server unreachable'));\r\n```\r\n\r\nSo, a basic implementation of an authentication strategy based on an abstract\r\nHTTP authentication service could look something like that:\r\n\r\n```js\r\nvar request = require('request');\r\n\r\nvar Authenticator = exports.Authenticator = function(opts) {\r\n  this.myAuthenticationHost = opts.myAuthenticationHost;\r\n};\r\n\r\nAuthenticator.prototype.authenticate = function(credentials, cb) {\r\n  request({\r\n    url: this.myAuthenticationHost + '/auth',\r\n    method: 'POST',\r\n    json: true,\r\n    body: {\r\n      username: credentials.body.username,\r\n      password: credentials.body.password\r\n    }\r\n  }, function (err, res, body) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    if (res.statusCode !== 200) {\r\n      return cb(null, {\r\n        message: 'Authentication failed'\r\n      });\r\n    }\r\n\r\n    return cb(null, {\r\n      token: body.token,\r\n      user: body.user\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n## Implementing your own authorization strategy\r\n\r\n### npm Enterprise authorization flow\r\n\r\n1. With each request npm CLI makes it sends a token previously received from the\r\nfrontdoor by the way of `npm login`.\r\n2. Unless specified otherwise, frontdoor checks the authorization token on\r\nevery request by calling the authentication webservice.\r\n3. Authentication webservice calls its configured authorization strategy, passing\r\nthe token to it and request context to it.\r\n4. Authorization strategy either returns whether authorization was successful\r\nor not.\r\n5. If authorization succeeded, and session store has a session for this token,\r\nfrontdoor allows the request to go through.\r\n\r\n### Authorization strategy API\r\n\r\nYour module needs to export an `Authorizer` property. `Authorizer` is called\r\nwith an object containing options for the running npm Enterprise instance\r\nand needs to return an object with an `authorize` function, for example:\r\n\r\n```js\r\nvar Authorizer = exports.Authorizer = function(opts) {\r\n};\r\n\r\nAuthorizer.prototype.authorize = function(credentials, cb) {\r\n};\r\n```\r\n\r\nor\r\n\r\n```js\r\nexports.Authorizer = function (opts) {\r\n  function authorize(credentials, cb) {\r\n  }\r\n\r\n  return {\r\n    authorize: authorize\r\n  };\r\n};\r\n```\r\n\r\nThe `authorize` function is called with an object that looks similar to this:\r\n\r\n```js\r\n{\r\n  path: '/mymodule',\r\n  method: 'PUT',\r\n  headers: {\r\n    // ...\r\n    referer: 'npm publish',\r\n    authorization: 'Bearer ...'\r\n  },\r\n  body: {\r\n    // request body\r\n  }\r\n}\r\n```\r\n\r\nBasing on this, you should authorize the user.\r\n\r\nIf authorization succeeds, you should call the callback with no error and `true`.\r\n\r\n```js\r\ncb(null, true);\r\n```\r\n\r\nIf authorization fails, you should call the callback with no error and `false`.\r\n\r\n```js\r\ncb(null, false);\r\n```\r\n\r\nIf authorization errors out (for example, your internal authorization server\r\nis down), you should call the callback with an error object:\r\n\r\n```js\r\ncb(new Error('Internal authorization server unreachable'));\r\n```\r\n\r\nSo, here's an example of using an abstract HTTP authorization service:\r\n\r\n```js\r\nvar request = require('request');\r\n\r\nvar Authorizer = exports.Authorizer = function(opts) {\r\n  this.myAuthorizationHost = opts.myAuthorizationHost;\r\n};\r\n\r\nAuthorizer.prototype.authorize = function(credentials, cb) {\r\n  if (!credentials.headers.authorization ||\r\n      !credentials.headers.authorization.match(/Bearer /)) {\r\n    return cb(null, false);\r\n  }\r\n\r\n  request({\r\n    url: this.myAuthorizationHost + '/authorize',\r\n    method: 'POST',\r\n    json: true,\r\n    body: {\r\n      token: credentials.headers.authorization.replace('Bearer ', '')\r\n    }\r\n  }, function (err, res, body) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    if (res.statusCode !== 200) {\r\n      return cb(null, false);\r\n    }\r\n\r\n    return cb(null, true);\r\n  });\r\n};\r\n```\r\n\r\nSince you have access to the `package.json`, if one is being sent by npm,\r\nyour authorization can involve various checks based on it. For example, GitHub\r\nauthorization plugin uses the `repository` field in connection with using GitHub\r\ntoken as the authorization token to determine if user has write access to the\r\npackage they are trying to publish.\r\n\r\n## Implementing your own session handler\r\n\r\nSession handler is used by the authentication webservice to persist user's name\r\nand email, keyed by the token created by the authentication strategy.\r\n\r\nThe point of creating custom session handlers is to provide strategy-specific\r\nfallbacks for when user tries authorizing requests against an npm Enterprise\r\ninstance without the token present in the session store.  \r\nFor example, GitHub strategy provides a custom session store which first checks\r\nRedis for the token, and if it's not present there, it attempts to authenticate\r\nwith GitHub with the same token. If GitHub authentication succeeds, user's\r\nGitHub email and login are persisted back to Redis.\r\n\r\n### npm Enterprise session flow\r\n\r\n#### Authentication\r\n\r\nSee [npm Enterprise authentication flow](#npm-enterprise-authentication-flow)\r\nfor exact description of the authentication flow.\r\n\r\n1. Frontdoor host calls the authentication webservice with a payload including\r\nthe credentials user input.\r\n2. Authentication webservice calls its configured authentication strategy, passing\r\nthe payload received to it.\r\n3. If authentication strategy succeeds, a token is returned.\r\n4. Session handler is called with a key (in form of `\"user-\" + token`), and\r\nsession data to persist.\r\n\r\n#### Authorization\r\n\r\nSee [npm Enterprise authorization flow](#npm-enterprise-authorization-flow)\r\nfor exact description of the authorization flow.\r\n\r\n1. With each request npm CLI makes it sends a token previously received from the\r\nfrontdoor by the way of `npm login`.\r\n2. Unless specified otherwise, frontdoor checks the authorization token on\r\nevery request by calling the authentication webservice.\r\n3. Authentication webservice calls its configured authorization strategy, passing\r\nthe token and request context to it.\r\n4. Authorization strategy returns whether authorization was successful or not.\r\n5. If authorization succeeded, session store is called with a key (in form of\r\n`\"user-\" + token`) to retrieve.\r\n\r\n### Session handler API\r\nYour module needs to export a `Session` property. `Session` is called with an\r\nobject containing options for the running npm Enterprise instance and needs to\r\nreturn an object with `get` and `set` functions.\r\n\r\n```js\r\nvar Session = exports.Session = function(opts) {\r\n};\r\n\r\nSession.prototype.get = function(key, cb) {\r\n};\r\n\r\nSession.prototype.set = function(key, session, cb) {\r\n};\r\n```\r\n\r\nor\r\n\r\n```js\r\nexports.Session = function (opts) {\r\n  function get(key, cb) {\r\n  }\r\n\r\n  function set(key, session, cb) {\r\n  }\r\n\r\n  return {\r\n    get: get,\r\n    set: set\r\n  };\r\n};\r\n```\r\n\r\nThe `get` function is called with a key to retrieve from the session store.\r\nIf getting the key from session store succeeds, you should call the callback\r\nwith the session content.\r\n\r\n```js\r\ncb(null, {\r\n  name: 'foobar',\r\n  email: 'foobar@mycorp.com'\r\n});\r\n```\r\n\r\nIf getting the key fails, you should call the callback with an error.\r\n\r\n```js\r\ncb(new Error('No such key'));\r\n```\r\n\r\nThe `set` function is called with a key and data to persist into the session\r\nstore. If storing the key succeeds, you should call the callback without an\r\nerror. If storing the key fails, you should call the callback with an error.\r\n\r\nHere's an example of using a Redis-based session store, which fails over to\r\nan abstract HTTP-based authorization service:\r\n\r\n```js\r\nvar request = require('request');\r\nvar redis = require('redis');\r\n\r\nvar Session = exports.Session = function(opts) {\r\n  this.myAuthorizationHost = opts.myAuthorizationHost;\r\n  this.redis = redis.createClient();\r\n};\r\n\r\nSession.prototype._lookup = function(key, cb) {\r\n  var self = this;\r\n\r\n  request({\r\n    url: this.myAuthenticationHost + '/authorize',\r\n    method: 'POST',\r\n    json: true,\r\n    body: {\r\n      token: key.split('-').splice(1).join('-')\r\n    }\r\n  }, function (err, res, body) {\r\n    if (err) {\r\n      return cb(err);\r\n    }\r\n\r\n    if (res.statusCode !== 200) {\r\n      return cb(new Error('Authorization failed'));\r\n    }\r\n\r\n    var session = {\r\n      name: body.username,\r\n      email: body.email\r\n    };\r\n\r\n    self.set(key, session, function (err) {\r\n      if (err) {\r\n        return cb(err);\r\n      }\r\n      cb(null, session);\r\n    });\r\n  });\r\n};\r\n\r\nSession.prototype.get = function(key, cb) {\r\n  var self = this;\r\n  this.client.get(key, function(err, data) {\r\n    if (err) return cb(err);\r\n    if (data) return cb(null, JSON.parse(data));\r\n    self._lookup(key, cb);\r\n  });\r\n};\r\n\r\nSession.prototype.set = function(key, session, cb) {\r\n  this.client.set(key, JSON.stringify(session), cb);\r\n};\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}